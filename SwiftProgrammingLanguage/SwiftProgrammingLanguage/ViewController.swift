//
//  ViewController.swift
//  SwiftProgrammingLanguage
//
//  Created by admin on 2017/10/23.
//  Copyright © 2017年 alldk. All rights reserved.
//
/*lzy171023注:
 这个类，对应的是 The Swift Programming Language第二章（Language Guide）的内容：
 访问控制(Access control)
 本页内容包括:
 • 模块和源文件 (页 0)
 • 访问级别 (页 0)
 • 访问控制语法 (页 0)
 • 自定义类型 (页 0)
 • 子类 (页 0)
 • 常量、变量、属性、下标 (页 0)
 • 构造器 (页 0)
 • 协议 (页 0)
 • 扩展 (页 0)
 • 泛型 (页 0)
 • 类型别名 (页 0)
 
 访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现
 细节，并且可以为其他人可以访问和使用的代码提供接口。
 你可以明确地给单个类型(类、结构体、枚举)设置访问级别，也可以给这些类型的属性、方法、构造器、下标
 等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。
 Swift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代 码中都申明显式访问级别。其实，如果只是开发一个单一目标的应用程序，我们完全可以不用显式声明代码的访 问级别。
 
 第 2 章 Swift 教程 | 288
 注意
 为了简单起见，对于代码中可以设置访问级别的特性(属性、基本类型、函数等)，在下面的章节中我们会称之
 为“实体”。


 */
import UIKit

class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
      
        // MARK: - 模块和源文件
        /*lzy171024注:
         
         Swift 中的访问控制模型基于模块和源文件这两个概念。 模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以
         使用 import 关键字导入另外一个模块。
         在 Swift 中，Xcode 的每个目标(例如框架或应用程序)都被当作独立的模块处理。如果你是为了实现某个通用 的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被 导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。
         源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的 类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。
         
         */
        
        
        // MARK: - 访问级别
        /*lzy171024注:
         
         Swift 为代码中的实体提供了五种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源 文件所属的模块相关。
         • 开放访问 和 公开访问 可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件 里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为开放或者公开访 问。
         • 内部访问 可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况 下，某个接口只在应用程序或框架内部使用时，你可以将其设置为内部访问。
         • 文件私有访问 限制实体只能被所定义的文件内部访问。当需要把这些细节被整个文件使用的时候，使用文件 私有访问隐藏了一些特定功能的实现细节。
         • 私有访问 限制实体只能在所定义的作用域内使用。需要把这些细节被整个作用域使用的时候，使用文件私有 访问隐藏了一些特定功能的实现细节。
         开放访问 为最高(限制最少)访问级别，私有访问 为最低(限制最多)访问级别。
         
         开放访问只作用于类类型和类的成员，它和公开访问的区别如下:
         
         • 公开访问 或者其他更严访问级别的类，只能在它们定义的模块内部被继承。
         • 公开访问 或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。
         • 开放访问 的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。
         • 开放访问 的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。
         • 把一个类标记为开放，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的 类的代码了。
         */
        
        // MARK:==== 访问级别基本原则====
        /*lzy171024注:
         Swift 中的访问级别遵循一个基本原则:不可以在某个实体中定义访问级别更低(更严格)的实体。 例如:
         • 一个公开访问级别的变量，其类型的访问级别不能是内部，文件私有或是私有类型的。因为无法保证变量的 类型在使用变量的地方也具有访问权限。
         • 函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就会出现函数可以在任何地方被访 问，但是它的参数类型和返回类型却不可以的情况。
         关于此原则的各种情况的具体实现，将在下面的细节中体现。
         */
        
        // MARK:====默认访问级别====
        /*lzy171024注:
         如果你不为代码中的实体显式指定访问级别，那么它们默认为 internal 级别(有一些例外情况，稍后会进行说 明)。因此，在大多数情况下，我们不需要显式指定实体的访问级别。
         */
        
        // MARK:====单目标应用程序的访问级别====
        /*lzy171024注:
         当你编写一个单目标应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使 用，所以我们不需要明确设置访问级别，使用默认的访问级别 internal 即可。但是，你也可以使用文件私有访 问或私有访问级别，用于隐藏一些功能的实现细节。
         */
        
        // MARK:====框架的访问级别====
        /*lzy171024注:
         当你开发框架时，就需要把一些对外的接口定义为开放访问或公开访问级别，以便使用者导入该框架后可以正常 使用其功能。这些被你定义为对外的接口，就是这个框架的 API。
         第 2 章 Swift 教程 | 290
         注意 框架依然会使用默认的内部访问级别，也可以指定为文件私有访问或者私有访问级别。当你想把某个实体作为框 架的 API 的时候，需显式为其指定开放访问或公开访问级别。
         */
        
        // MARK:====单元测试目标的访问级别====
        /*lzy171024注:
         当你的应用程序包含单元测试目标时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有开 放访问或公开访问级别级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用
         ble 特性，然后在允许测试的编译设置( Build Options -> Enable Testability )下编译这个应用程序模块，单 元测试目标就可以访问应用程序模块中所有内部级别的实体。
         
         */
        
        // MARK: - 访问控制语法
        
        /*lzy171024注:
         通过修饰符 open，public，internal，filepart，private 来声明实体的访问级别:
         @testa
         public class SomePublicClass {}
         internal class SomeInternalClass {}
         fileprivate class SomeFilePrivateClass {}
         private class SomePrivateClass {}
         public var somePublicVariable = 0
         internal let someInternalConstant = 0
         fileprivate func someFilePrivateFunction() {}
         private func somePrivateFunction() {}
         除非专门指定，否则实体默认的访问级别为内部访问级别，可以查阅默认访问级别 (页 0)这一节。这意味着在不 使用修饰符显式声明访问级别的情况下，SomeInternalClass 和 someInternalConstant 仍然拥有隐式的内部访 问级别:
         
         class SomeInternalClass {} // 隐式内部访问级别 var someInternalConstant = 0 // 隐式内部访问级别
         */
        
        // MARK: - 自定义类型
        
        /*lzy171024注:
         如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。
         新类型只能在它的访问级别限制范围内使用。例如，你定义了一个文件私有级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型，等等。
         一个类型的访问级别也会影响到类型成员(属性、方法、构造器、下标)的默认访问级别。如果你将类型指定为
         私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。
         
         如果你将类型指定为 公开或者内部访问级别(或者不明确指定访问级别，而使用默认的内部访问级别)，那么该类型的所有成
         员的默认访问级别将是内部访问。
         
         重要
         上面提到，一个公开类型的所有成员的访问级别默认为内部访问级别，而不是公开级别。如果你想将某个成员指
         定为公开访问级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接
         口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。
         
         public class SomePublicClass {// 显示公开类
         public var somePublicProperty = 0 // 显示公开类成员
         var someInternalProperty = 0 // 隐式内部类成员
         fileprivate func someFilePrivateMethod() {} // 显式文件私有类成员
         }
         
         class SomeInternalClass { // 隐式内部类
         var someInternalProperty = 0 // 隐式内部类成员
         fileprivate func someFilePrivateMethod() {} // 显式文件私有类成员
         private func somePrivateMethod() {} // 显式私有类成员
         }
         
         fileprivate class SomeFilePrivateClass {// 显示文件私有 类
         func someFilePrivateMethod() {} // 隐式 文件私有类成员
         private func somePrivateMethod() {}// 显示 私有 类成员
         }
         private class SomePrivateClass {// 显示私有类
         func somePrivateMethod() {}// 隐式 私有类成员
         }
         */
        
        // MARK:====元组类型====
        /*lzy171024注:
         
         元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元
         组，其中一个类型为内部访问级别，另一个类型为私有访问级别，那么这个元组的访问级别为私有访问级别。
         
         注意
         元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法
         明确指定。
         
         */
        
        // MARK:====函数类型====
        /*lzy171024注:
         函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合
         函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。
         下面的例子定义了一个名为 someFunction() 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函 数应该拥有默认的访问级别 internal ，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编 译:
         func someFunction() -> (SomeInternalClass, SomePrivateClass) { // 此处是函数实现部分
         }
         我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类(可查阅自定义类型 (页 0))。其中一个类的访问级别是internal，另一个的访问级别是 private  ，所以根据元组访问级别的原则，该 元组的访问级别是private(元组的访问级别与元组中访问级别最低的类型一致)。
         因为该函数返回类型的访问级别是private，所以你必须使用private修饰符，明确指定该函数的访问级别:
         private func someFunction() -> (SomeInternalClass, SomePrivateClass) { // 此处是函数实现部分
         }
         将该函数指定为public或 internal，或者使用默认的访问级别internal都是错误的，因为如果把该函数 当做 public  或 internal  级别来使用的话，可能会无法访问 private  级别的返回值。
         */
        
        /*lzy171024注:
         枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。
         比如下面的例子，枚举 CompassPoint 被明确指定为 public级别，那么它的成员North、South、East、West 的访问级别同样也是 public:
         public enum CompassPoint {
             case North
             case South
             case East
             case West
         }
         */
        
        /*
         原始值和关联值
         枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 internal
         访问级别的枚举中定义private级别的原始值类型。
         */
        
        // MARK:====嵌套类型====
        /*lzy171024注:
         如果在 private级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有private访问级别。如果在 publicc 或者internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有internal访问级别。如果想让嵌套类型拥有public访问级别，那么需要明确指定该嵌套类型的访问级别。
         */
        
        // MARK: - 子类
        /*lzy171024注:
         子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 internal ，子类的访问级别就不能是 public 。
         此外，你可以在符合当前访问级别的条件下重写任意类成员(方法、属性、构造器、下标等)。
         可以通过重写为继承来的类成员提供更高的访问级别。下面的例子中，类 A 的访问级别是 public ，它包含一 个方法 someMethod() ，访问级别为 private 。类 B 继承自类 A ，访问级别为 internal ，但是在类 B 中 重写了类 A 中访问级别为 private 的方法 someMethod() ，并重新指定为 internal 级别。通过这种方 式，我们就可以将某类中 private 级别的类成员重新指定为更高的访问级别，以便其他人使用:
         public class A {
         private func someMethod() {}
         }
         internal class B: A {
         override internal func someMethod() {}
         }
         我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围 内(也就是说，在同一源文件中访问父类 private 级别的成员，在同一模块内访问父类 internal 级别的成 员):
         public class A {
         private func someMethod() {}
         }
         internal class B: A {
         override internal func someMethod() {
         super.someMethod()
         }
         }
         因为父类 A 和子类 B 定义在同一个源文件中，所以在子类 B 可以在重写的 someMethod() 方法中调用 s uper.someMethod() 。
         */
        
        // MARK: - 常量、变量、属性、下标
        /*lzy171024注:
         常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 public 级别的属性，但是它
         的类型却是 private 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。 如果常量、变量、属性、下标的类型是 private 级别的，那么它们必须明确指定访问级别为 private :
         private var privateInstance = SomePrivateClass()
         
         */
        
        // MARK:====Getter 和 Setter====
        /*lzy171024注:
         常量、变量、属性、下标的 Getters 和 Setters 的访问级别和它们所属类型的访问级别相同。
         Setter 的访问级别可以低于对应的 Getter 的访问级别，这样就可以控制变量、属性或下标的读写权限。在
         var 或 subscript 关键字之前，你可以通过 fileprivate(set)，private(set) 或 internal(set) 为它们 的写入权限指定更低的访问级别。
         注意
         这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 Getter 和 Setter ，Swift 也会隐式地为其创建 Getter 和 Setter ，用于访问该属性的后备存储。使用 fileprivate(set) ， private(s et) 和 internal(set) 可以改变 Setter 的访问级别，这对计算型属性也同样适用。
         
         */
    }
}
